---
import { getCollection, render } from 'astro:content';
import { DocumentationLayout } from '@layouts';
import { DocumentationHeader } from '@components';

export async function getStaticPaths() {
	// documentation index.mdx files
	const docs = await getCollection('docs');
	// source.mdx wrappers for the raw .js files
	const source = await getCollection('sourceCode');
	const contentEntries = [...docs, ...source];

	// paths for astro content collections (unchanged)
	const contentPaths = contentEntries.map((entry) => {
		const docsEntry = docs.find((e) => e.id === entry.id);
		const sourceEntry = source.find((e) => e.id === entry.id);
		return {
			params: { id: entry.id },
			props: { currentEntry: entry, docsEntry, sourceEntry },
		};
	});

	// TypeDoc API pages (raw files under docs/**/typedoc/**/*.md)
	const apiPages = import.meta.glob('/docs/**/typedoc/**/*.md');
	const apiPaths = Object.keys(apiPages).flatMap((file) => {
		/*
		 * file example: /docs/servicenow/check/typedoc/classes/Checker.md
		 * strip leading /docs/ (Astro route already has /docs)
		 * strip /typedoc/ from the public url
		 * strip .md for canonical, extensionless URLs
		 */
		const apiId = file
			.replace(/^\/docs\//, '')
			.replace('/typedoc/', '/')
			.replace(/\.md$/, '');

		console.log(apiId);

		return [
			// return paths for with and without the extension
			{
				params: { id: apiId },
				props: { apiPath: file },
			},
			{
				params: { id: apiId + '.md' },
				props: { apiPath: file },
			},
		];
	});

	return [...contentPaths, ...apiPaths];
}

const { currentEntry, apiPath } = Astro.props;

let Content;
let apiHtml = null;

if (currentEntry) {
	// render content from Astro collections
	const rendered = await render(currentEntry);
	Content = rendered.Content;
} else if (apiPath) {
	// render generated TypeDoc markdown
	const apiPages = import.meta.glob('/docs/**/typedoc/**/*.md');
	const loader = apiPages[apiPath];

	if (!loader) {
		throw new Error(`No TypeDoc page found for path: ${apiPath}`);
	}

	const mod = await loader();

	// Get compiled HTML for the markdown file
	const rawHtml = await mod.compiledContent?.();

	if (!rawHtml) {
		throw new Error(`No compiledContent() for TypeDoc page: ${apiPath}`);
	}

	// base URL is the current request path without the file name
	// i.e., /docs/servicenow/check/classes/Checker -> /docs/servicenow/check/classes
	const pathname = Astro.url.pathname.replace(/\/+$/, ''); // trim trailing slash
	const baseUrl = pathname.replace(/\/[^/]*$/, '');

	apiHtml = rewriteRelativeLinks(rawHtml, baseUrl);
}

/**
 * Rewrite TypeDocs's relative links so they match Astro routes,
 * which does not include /typedoc/ in the path. Does not update non-relative routes.
 */
function rewriteRelativeLinks(html, base) {
	const regex = new RegExp('href="(?!https?:\/\/|/|#)([^"]+)"', 'g');
	return html.replace(regex, (_match, rel) => {
		// drop .md extension from targets to match extensionless routes
		const cleanRel = rel.replace(/\.md$/, '');
		const normalizedBase = base.replace(/\/+$/, '');
		return `href="${normalizedBase}/${cleanRel}"`;
	});
}
---

<DocumentationLayout>
	<div class="flex flex-col">
		{currentEntry && <DocumentationHeader entry={currentEntry} />}
		{currentEntry && Content && <Content />}
		{!currentEntry && apiHtml && <div set:html={apiHtml} />}
	</div>
</DocumentationLayout>
