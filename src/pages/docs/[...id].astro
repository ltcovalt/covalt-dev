---
// @ts-nocheck
import { getCollection, render } from 'astro:content';
import { DocumentationLayout } from '@layouts';
import { DocsHeader, Alert, Link } from '@components';
import { extractBreadcrumbs } from '@utils/typedoc.js';

export async function getStaticPaths() {
	// documentation index.mdx files
	const docs = await getCollection('apiIndexDocs');
	// source.mdx wrappers for the raw .js files
	const source = await getCollection('sourceCode');
	const contentEntries = [...docs, ...source];
	// map api id (i.e., servicenow/client/query-ajax) to display name (QueryAjax)
	const apiIdToNameMap = Object.fromEntries(docs.map((e) => [e.id, e.data.env.api]));
	// paths for astro content collections
	const contentPaths = contentEntries.map((entry) => {
		let indexEntry = null;
		if (entry.collection === 'apiIndexDocs') {
			indexEntry = entry;
		} else if (entry.collection === 'sourceCode') {
			// source wrappers live next to index.mdx
			// e.g. servicenow/type/source -> servicenow/type/index or servicenow/type
			const indexPath = entry.id.replace(/\/source$/, '');
			indexEntry = docs.find((d) => d.id === indexPath) ?? null;
		}

		return {
			params: { id: entry.id },
			props: { contentEntry: entry, indexEntry, apiIdToNameMap },
		};
	});

	// TypeDoc API pages (raw files under docs/**/typedoc/**/*.md)
	const apiPages = import.meta.glob('/docs/**/typedoc/**/*.md');
	const apiPaths = Object.keys(apiPages).flatMap((file) => {
		/**
		 * file example: /docs/servicenow/server/check/typedoc/classes/Checker.md
		 * srip leading /docs/, as Astro route already includes /docs
		 */
		const withoutPrefix = file.replace(/^\/docs\//, ''); // servicenow/check/typedoc/classes/Checker.md

		// root api id = servicenow/server/check
		const rootApiId = withoutPrefix.split('/typedoc/')[0];

		const indexEntry = docs.find((d) => d.id === rootApiId) ?? null;

		/*
		 * file example: /docs/servicenow/check/typedoc/classes/Checker.md
		 * strip leading /docs/ (Astro route already has /docs)
		 * strip /typedoc/ from the public url
		 * strip .md for canonical, extensionless URLs
		 */
		const apiId = file
			.replace(/^\/docs\//, '')
			.replace('/typedoc/', '/')
			.replace(/\.md$/, '');

		return [
			// return paths for with and without the extension
			{
				params: { id: apiId },
				props: { apiPath: file, indexEntry, apiIdToNameMap },
			},
			{
				params: { id: apiId + '.md' },
				props: { apiPath: file, indexEntry, apiIdToNameMap },
			},
		];
	});

	return [...contentPaths, ...apiPaths];
}

const { contentEntry, indexEntry, apiPath, apiIdToNameMap } = Astro.props;

let Content;
let typedocContent = null;
let breadcrumbHtml = null;

if (contentEntry) {
	// render content from Astro collections (index or source wrapper)
	const rendered = await render(contentEntry);
	Content = rendered.Content;
} else if (apiPath) {
	// render generated TypeDoc markdown
	const apiPages = import.meta.glob('/docs/**/typedoc/**/*.md');
	const loader = apiPages[apiPath];

	if (!loader) throw Error(`No TypeDoc page found for path: ${apiPath}`);

	const mod = await loader();
	// Get compiled HTML for the markdown file
	const rawHtml = await mod.compiledContent?.();

	if (!rawHtml) throw Error(`No compiledContent() for TypeDoc page: ${apiPath}`);

	// base URL is the current request path without the file name
	// i.e., /docs/servicenow/check/classes/Checker -> /docs/servicenow/check/classes
	const pathname = Astro.url.pathname.replace(/\/+$/, ''); // trim trailing slash
	const baseUrl = pathname.replace(/\/[^/]*$/, '');

	typedocContent = rewriteRelativeLinks(rawHtml, baseUrl);

	let extracted = extractBreadcrumbs(typedocContent);
	typedocContent = extracted.html ?? typedocContent;
	breadcrumbHtml = extracted.breadcrumbHtml;
}

/**
 * Rewrite TypeDocs's relative links so they match Astro routes,
 * which does not include /typedoc/ in the path. Does not update non-relative routes.
 */
function rewriteRelativeLinks(html, base) {
	const regex = new RegExp('href="(?!https?:\/\/|/|#)([^"]+)"', 'g');
	return html.replace(regex, (_match, rel) => {
		// drop .md extension from targets to match extensionless routes
		const cleanRel = rel.replace(/\.md$/, '');
		const normalizedBase = base.replace(/\/+$/, '');
		return `href="${normalizedBase}/${cleanRel}"`;
	});
}
---

<DocumentationLayout>
	{breadcrumbHtml && <div slot="docs-header" class="breadcrumb" set:html={breadcrumbHtml} />}
	<DocsHeader {indexEntry} {apiIdToNameMap} />
	{contentEntry && Content && <Content components={{ Alert, Link }} />}
	{!contentEntry && typedocContent && <div set:html={typedocContent} />}
</DocumentationLayout>
