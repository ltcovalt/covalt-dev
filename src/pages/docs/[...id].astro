---
// @ts-nocheck
import { getCollection, render } from 'astro:content';
import { DocumentationLayout } from '@layouts';
import { DocsHeader, Alert, Link } from '@components';
import { Fragment } from 'astro/jsx-runtime';
import {
	extractBreadcrumbs,
	getTypedocPageMap,
	loadCompiledHtmlFromGlob,
	typedocDiskPathToRootApiId,
	typedocDiskPathToPublicId,
	pathnameToBaseUrl,
	rewriteRelativeLinks,
} from '@utils/typedoc.js';

/**
 * getStaticPaths() defines all public /docs routes
 *
 * API index collection routes: /docs/<apiRootId>
 * API source code collection routes: /docs/<apiRootId>/source
 *
 * TypeDoc disk path: /docs/<apiRootId>/typedoc/<restPath>.md
 * TypeDoc public routes:
 * - /docs/<apiRootId>/<restPath>.md
 * - /docs/<apiRootId>/<restPath>
 *
 * Notes:
 * - <apiRootId> is the content collection id for the API index (i.e., servicenow/server/check).
 * - TypeDoc routes strip /typedoc/ from the public route and emit routes with and without extensions
 * - TypeDoc generated subdirectories (classes, functions, etc.) are typically preserved,
 *   except for namespaces which will collapse redundant API/module/namespace in the future
 *   TODO: i.e., /docs/servicenow/server/query/typedoc/Query/namespaces/Query -> /docs/servicenow/server/query
 */
export async function getStaticPaths() {
	// documentation index.mdx files
	const docs = await getCollection('apiIndexDocs');
	// source.mdx wrappers for the raw .js files
	const source = await getCollection('sourceCode');
	const contentEntries = [...docs, ...source];
	// map api id (i.e., servicenow/client/query-ajax) to display name (QueryAjax)
	const apiIdToNameMap = Object.fromEntries(docs.map((e) => [e.id, e.data.env.api]));
	// paths for astro content collections
	const contentPaths = contentEntries.map((entry) => {
		let indexEntry = null;
		if (entry.collection === 'apiIndexDocs') {
			indexEntry = entry;
		} else if (entry.collection === 'sourceCode') {
			/*
			 * source wrappers live next to index.mdx
			 * i.e. servicenow/server/type/source -> servicenow/server/type (index.mdx)
			 */
			const indexPath = entry.id.replace(/\/source$/, '');
			indexEntry = docs.find((d) => d.id === indexPath) ?? null;
		}

		return {
			params: { id: entry.id },
			props: { contentEntry: entry, indexEntry, apiIdToNameMap },
		};
	});

	// TypeDoc API pages (raw files under docs/**/typedoc/**/*.md)
	const apiPages = getTypedocPageMap();
	const apiPaths = Object.keys(apiPages).flatMap((file) => {
		/**
		 * rootApiId is the directory immediately above /typedoc
		 * file example: /servicenow/server/check/typedoc/classes/Checker.md
		 * rootApiId: servicenow/server/check
		 */
		const rootApiId = typedocDiskPathToRootApiId(file);
		const indexEntry = docs.find((d) => d.id === rootApiId) ?? null;

		/*
		 * convert a typedoc file path as it exists on disk to a public ID
		 * i.e., /docs/servicenow/check/typedoc/classes/Checker.md
		 * becomes servicenow/check/classes/Checker
		 */
		const apiId = typedocDiskPathToPublicId(file);

		return [
			// return paths for with and without the extension
			{
				params: { id: apiId },
				props: { apiPath: file, indexEntry, apiIdToNameMap },
			},
			{
				params: { id: apiId + '.md' },
				props: { apiPath: file, indexEntry, apiIdToNameMap },
			},
		];
	});

	return [...contentPaths, ...apiPaths];
}

const { contentEntry, indexEntry, apiPath, apiIdToNameMap } = Astro.props;

let Content;
let typedocContent = null;
let breadcrumbHtml = null;

if (contentEntry) {
	// render content from Astro collections (index or source wrapper)
	const rendered = await render(contentEntry);
	Content = rendered.Content;
} else if (apiPath) {
	// render generated TypeDoc markdown
	const apiPages = getTypedocPageMap();
	const rawHtml = await loadCompiledHtmlFromGlob(apiPages, apiPath, 'TypeDoc page');

	/*
	 * Base URL is the current request path without the file name
	 * i.e., /docs/servicenow/check/classes/Checker -> /docs/servicenow/check/classes
	 */
	const baseUrl = pathnameToBaseUrl(Astro.url.pathname);
	typedocContent = rewriteRelativeLinks(rawHtml, baseUrl, { stripMdExt: true });

	let extracted = extractBreadcrumbs(typedocContent);
	typedocContent = extracted.html ?? typedocContent;
	breadcrumbHtml = extracted.breadcrumbHtml;
}
---

<DocumentationLayout>
	<Fragment slot="docs-header">
		{breadcrumbHtml && <div class="breadcrumb px-4" set:html={breadcrumbHtml} />}
		<DocsHeader class="docs-hero" {indexEntry} {apiIdToNameMap} />
	</Fragment>
	{contentEntry && Content && <Content components={{ Alert, Link }} />}
	{!contentEntry && typedocContent && <div class="px-4" set:html={typedocContent} />}
</DocumentationLayout>
