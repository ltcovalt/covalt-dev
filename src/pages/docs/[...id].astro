---
// @ts-nocheck
import { getCollection, render } from 'astro:content';
import { DocumentationLayout } from '@layouts';
import { DocsHeader, Alert, Link } from '@components';

export async function getStaticPaths() {
	// documentation index.mdx files
	const docs = await getCollection('docs');
	// source.mdx wrappers for the raw .js files
	const source = await getCollection('sourceCode');
	const contentEntries = [...docs, ...source];

	// paths for astro content collections
	const contentPaths = contentEntries.map((entry) => {
		let indexEntry = null;
		let sourceEntry = null;

		if (entry.collection === 'docs') {
			// index pages are the meta source
			indexEntry = entry;
		} else if (entry.collection === 'sourceCode') {
			sourceEntry = entry;

			// source wrappers live next to index.mdx
			// e.g. servicenow/type/source -> servicenow/type/index or servicenow/type
			const indexPath = entry.id.replace(/\/source$/, '');
			indexEntry = docs.find((d) => d.id === indexPath) ?? null;
		}

		return {
			params: { id: entry.id },
			props: { currentEntry: entry, indexEntry, sourceEntry },
		};
	});

	// TypeDoc API pages (raw files under docs/**/typedoc/**/*.md)
	const apiPages = import.meta.glob('/docs/**/typedoc/**/*.md');
	const apiPaths = Object.keys(apiPages).flatMap((file) => {
		/**
		 * file example: /docs/servicenow/server/check/typedoc/classes/Checker.md
		 * srip leading /docs/, as Astro route already includes /docs
		 */
		const withoutPrefix = file.replace(/^\/docs\//, ''); // servicenow/check/typedoc/classes/Checker.md

		// root api id = servicenow/server/check
		const rootApiId = withoutPrefix.split('/typedoc/')[0];

		const indexEntry = docs.find((d) => d.id === rootApiId) ?? null;

		/*
		 * file example: /docs/servicenow/check/typedoc/classes/Checker.md
		 * strip leading /docs/ (Astro route already has /docs)
		 * strip /typedoc/ from the public url
		 * strip .md for canonical, extensionless URLs
		 */
		const apiId = file
			.replace(/^\/docs\//, '')
			.replace('/typedoc/', '/')
			.replace(/\.md$/, '');

		return [
			// return paths for with and without the extension
			{
				params: { id: apiId },
				props: { apiPath: file, indexEntry },
			},
			{
				params: { id: apiId + '.md' },
				props: { apiPath: file, indexEntry },
			},
		];
	});

	return [...contentPaths, ...apiPaths];
}

const { currentEntry, indexEntry, apiPath } = Astro.props;

let Content;
let apiHtml = null;

if (currentEntry) {
	// render content from Astro collections (index or source wrapper)
	const rendered = await render(currentEntry);
	Content = rendered.Content;
} else if (apiPath) {
	// render generated TypeDoc markdown
	const apiPages = import.meta.glob('/docs/**/typedoc/**/*.md');
	const loader = apiPages[apiPath];

	if (!loader) throw Error(`No TypeDoc page found for path: ${apiPath}`);

	const mod = await loader();
	// Get compiled HTML for the markdown file
	const rawHtml = await mod.compiledContent?.();

	if (!rawHtml) throw Error(`No compiledContent() for TypeDoc page: ${apiPath}`);

	// base URL is the current request path without the file name
	// i.e., /docs/servicenow/check/classes/Checker -> /docs/servicenow/check/classes
	const pathname = Astro.url.pathname.replace(/\/+$/, ''); // trim trailing slash
	const baseUrl = pathname.replace(/\/[^/]*$/, '');

	apiHtml = rewriteRelativeLinks(rawHtml, baseUrl);
}

/**
 * Rewrite TypeDocs's relative links so they match Astro routes,
 * which does not include /typedoc/ in the path. Does not update non-relative routes.
 */
function rewriteRelativeLinks(html, base) {
	const regex = new RegExp('href="(?!https?:\/\/|/|#)([^"]+)"', 'g');
	return html.replace(regex, (_match, rel) => {
		// drop .md extension from targets to match extensionless routes
		const cleanRel = rel.replace(/\.md$/, '');
		const normalizedBase = base.replace(/\/+$/, '');
		return `href="${normalizedBase}/${cleanRel}"`;
	});
}
---

<DocumentationLayout>
	<div class="flex flex-col">
		<DocsHeader {indexEntry} />
		{currentEntry && Content && <Content components={{ Alert, Link }} />}
		{!currentEntry && apiHtml && <div set:html={apiHtml} />}
	</div>
</DocumentationLayout>
