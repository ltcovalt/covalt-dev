---
title: Basic tree utility functions
slug: tree-traverse-to-root
description: Basic tree utility functions for getting neighboring nodes
author: "Luke Covalt"
date: 2025-09-20
updated: 2025-09-20
draft: true
tags: [blog]
---

import Link from "@components/Link.astro";
import Alert from "@components/Alert.astro";

I'm going to start off with some relatively simple basic functions that our Tree
functions will need. I plan to expose all these functions under a script include
namespace called "Tree".

## Creating the Tree namespace

In ServiceNow, I typically prefer exposing standalone methods under a namespace,
rather than a class. I may go into more detail on why I prefer this pattern and
cover some of the other options, but it's not overly important for now. We'll
just create a new script include named Tree with the tiny boiler plate below.

#### Tree.js

```js
const Tree = {};
(() => {
  // TODO
})();
```

The first line creates the Tree namespace that we can attach our publicly
exposed methods and properties to. The immediately invoked function expression
(IIFE) just below is used so that we can declare private functions and variables
if needed. Anything defined within the IIFE will be accessible only within the
IIFE. For the methods we want to expose to other users, we add it as a property
on the Tree object.

## Get root node

Getting the root node is pretty simple - we just get the parent node repeatedly
until there are no more parent nodes. This could be done in a loop, but I think
a simple recursive function makes things cleaner.

```js
const Tree = {};
(() => {
  /**
   * returns the root node of a given node
   * @param {object} params - named function parameters
   * @param {GlideRecord} params.node - the current node being processed
   * @param {string} [params.parentField=parent] - name of the parent reference field
   */
  Tree.getRootNode = ({ node, parentField = "parent" }) => {
    if (!node || !node.isValidRecord())
      throw Error("missing or invalid parameter: node");
    // no more parent fields - this is our root node
    if (!node[parentField]) return node;
    // get the parent node, then call the function again using the parent node
    let parentNode = node[parentField].getRefRecord();
    return Tree.getRootNode({ node: parentNode, parentField });
  };
})();
```

This works, but there is a potential issue. We could have a cyclic recursion,
where nodes are related as `A->B->C->A`. Depending on the use case and the
table, this type of scenario can easily be prevented with a business rule, but
since we don't know where our utilities will end up being used, I think it is
best to make them as generic and robust as possible.

## Preventing endless recursion

We can use a `Set` to track the call stack/visited nodes of the current branch.
Each time we call our function, we push that node to our set. When the function
completes, we remove the node from our stack. This allows the same node to
appear multiple times in the tree, but not multiple times in the same branch,
which would cause endless recursinon.

As an example, depending on the schema design, we might have a valid scenario
where the same node (`Leaf01` in this case) appears multiple times in the tree
by design, most frequently in many-to-many relationships.

```
Root
├── Intermediate_01
│	└── Leaf
└── Intermediate_02
	└── Leaf
```

But we never want to allow a scenario like below, or the function recurse
infinitely. We will throw an `Error` if we encounter branch with a reference loop.

```
Leaf
└── Root
	└── Intermediate
		└── Leaf
```
