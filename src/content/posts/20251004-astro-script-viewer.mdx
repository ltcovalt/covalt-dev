---
title: Astro Script Viewer
slug: astro-script-viewer
description: Build an astro layout for rendering and navigating script files
author: "Luke Covalt"
date: 2025-10-04
updated: 2025-10-04
draft: false
tags: [blog, api, documentation, javascript, jsdoc, script viewer, markdown]
---

A major feature missing from this site is a nice way to view full scripts and
related API documentation. Many of my posts link out directly to the GitHub repo
for this site when I want to share a specific script. It would be much nicer if
I could link to those files directly on this site.

Of course, Astro natively supports the rendering of markdown code fences, which
I make heavy use of in my posts - but I want a page to view full scripts that
won't force the prose word wrap style, which sometimes causes scripts to be
formatted in strange ways. This should not be too difficult to implement, so
I'll tackle this feature first.

API documentation will likely be a bit more involved. I know generators exist to
automatically build documentation pages from JSDOC comments, which I always use
to document my JavaScript. I'm not sure if Astro has an official integration
that supports generating this, so that is something I'll have to look into in
the future.

## Evaluating script rendering options in Astro

Early in this project, I anticipated I would want to embed and share scripts, so
I have been storing them at `/src/content/scripts`. These aren't scripts that
are used in any way by my website, they are strictly content intended to be
shared with others. At the time, storing scripts as content made sense - it
clearly separated them from other `/src` scripts that contains logic for my
site. Unfortunately, I hit a minor snag - Astro content collections doesn't
recognize `.js` files as content, so I can't create a collection directly from
my files.

I have a couple options, but each has its own drawbacks. I could just import my
source files as raw text, bypassing Astro's markdown rendering pipeline
entirely, and handle styling myself with a library like
[Prism](https://prismjs.com) or [Shiki](https://shiki.matsu.io/). This means I
would have full control of styling, but it would be extra work to maintain and I
would have to reimplement some features that I already built as remark and
rehype plugins. To keep things consistent across the site, I am pretty confident
the best solution for me will be to have them rendered through Astro's standard
rendering pipeline.

To have my scripts processed through Astro's renderer, I could create a simple
markdown file that wraps my script. I could then create a standard Astro
collection of these markdown files and render them like usual. However, I also
want to be able to share the exact script contents, free of any additional
markup, so it can be easily downloaded and used by others.

Finally, I briefly considered Starlight, Astro's own documentation site
solution. I know I will want API doc pages in the future, but I am currently
leaning towards building my own solution so that the look and feel is perfectly
integrated with my current themes and styles used for my site and blog.

## Choosing a solution

In the end, I decided to go with a solution that will require a little manual
upkeep from me. I will maintain the raw source files and create a simple wrapper
markdown file that injects the source code. These markdown files can be used in
a regular Astro collection and rendered like normal.

## CodeLayout

The first thing I need is a new layout component that can display my script
files. In my project, they are located at `/src/layouts`, so I'll create a new
layout named `CodeLayout.astro` in this directory that uses my default layout as
a base.

#### CodeLayout.astro

```astro
---
import DefaultLayout from "./DefaultLayout.astro";
const { title = "covalt.dev" } = Astro.props;
---

<DefaultLayout {title}>
  <div class="prose xl:prose-lg m-auto max-w-[120ch] p-8">
    <slot />
  </div>
</DefaultLayout>
```

For now, I'll use the same basic settings as my `ArticleLayout.astro` layout
used for my blog posts, except that I will change the prose wrap from 75ch to
120ch. I'll have to wait and see what it actually looks like when it's rendered,
but I wrap at 120 characters in my IDE, so this seems like a sane starting
point.

## Moving my content scripts

Knowing that I plan to have a docs site in the future, I moved my scripts from
`/src/content/` to `/docs/code`. These are my raw, source files free of any
additional markup.

## Wrapping the source in markdown

Next, I need an Astro content collection to render my scripts. For this, I
create a new file for each API I want a page for. For the ServiceNow Tree API I
have been working on most recently, that would be located at
`/src/content/code/servicenow/Tree.mdx`. I don't want to maintain two separate
script files - so I use the `remark-code-import` plugin to import my source code
from `/docs/code/servicenow/Tree.js` directly.

While creating a wrapper like this is a small amount of manual effort, it also
means I can embed frontmatter, like a user friendly title, description, and
tags. Since I won't be frequently creating new wrappers, I don't mind a bit of
manual effort, but we could automate the generation of these wrapper files in
the future if needed.

## Create an Astro collection

With our source files wrapped in a minimal markdown document, they can be used
in Astro collections like normal. We just need to update `content.config.js` to
define the new collection. Here is my config that defines a Posts and a Code
collection.

#### content.config.js

```js
import { defineCollection } from "astro:content";
import { glob, file } from "astro/loaders";

// define collections
const posts = defineCollection({
  loader: glob({ pattern: "**/*.{md,mdx}", base: "./src/content/posts" }),
});

const code = defineCollection({
  loader: glob({ pattern: "**/*.{md,mdx}", base: "./src/content/code" }),
});

// export all collections as a single collections object
export const collections = { posts, code };
```

## Rendering the Code collection

The final step is to create a new Astro page that will render the content. I'll
share my complete page code here for reference, but I don't want to go into much
detail, as the official
[Astro Docs](https://docs.astro.build/en/guides/content-collections/) do an
excellent job explaining how to configure, query, and render collections as well
as how to generate static paths for the content.

Create a new page `/src/pages/code/[...id].astro`. The `[...id]` bit ensures
that subpaths are matched too. For example, where `[id].astro` would only match
`/code/file-id`, `[...id].astro` will match `/code/file-id`,
`/code/servicenow/file-id`, and any other sub-path created in the future under
`code`.

#### /src/pages/code/[...id].astro

```astro
---
import { getCollection, render } from "astro:content";
import CodeLayout from "@layouts/CodeLayout.astro";

export async function getStaticPaths() {
  const entries = await getCollection("code");
  return entries.map((entry) => ({
    params: { id: entry.id },
    props: { entry },
  }));
}

const { entry } = Astro.props;
const { Content } = await render(entry);
---

<CodeLayout title={entry.data.title}>
  <Content />
</CodeLayout>
```

## Wrapping up and Review

The final thing to do is ensure the scripts are accessible under the expected
path. At the time of writing, I've only published one API, but it should be
accessible by navigating to
[https://covalt.dev/code/servicenow/tree](/code/servicenow/tree).

Here's a final recap of the end-to-end solution and process.

1. Source files are stored at `/docs/code`
2. Source files are injected into a simple wrapper markdown file at
   `/src/content/code` using the `remark-code-import` plugin
3. Define a new code collection in `content.config.js` containing the files from
   `/src/content/code`
4. Create a new page `/src/pages/code/[...id].astro` to render the collection

This certainly isn't the final solution, as I will want a full-featured docs
browser in the future, but it solves my immediate needs. Now I can easily render
full scripts without linking out to my GitHub repo.
