---
title: Input Validation and Type Checking Library
slug: servicenow-input-and-type-validation
description:
    Build a fluent, chainable API for performing input validation, type
    checking, and error handling in ServiceNow using a standard JavaScript class
    and namespace.
author: 'Luke Covalt'
date: 2025-11-11
updated: 2025-11-11
draft: false
tags:
    [JavaScript, ServiceNow, class, namespace, facade, type, assert, validation]
---

I originally started working on a generic AJAX query utility (I'll update this
post with a link when it is ready) when I remembered how tedious and verbose
simple input parameter validation and type checking can be. So I had a change of
heart and will be working on a type/value checking and assertion library
instead. I think it will be useful - but I admit, I attempted this once before
and my resulting library was too verbose, and I ultimately ended up scrapping
the utility, because it didn't eliminate as much boiler plate as I had hoped.
With the introduction of modern JavaScript to ServiceNow server-side scripts,
I'm going to give it another shot. Although I'm building this solution in
ServiceNow, it is all done using vanilla JavaScript APIs and could be easily
used elsewhere.

## API structure and goals

First, the API needs to be concise and very clear at a glance what
validation/checking is being performed. I'm going to take a note from other
testing and assertion libraries, like Chai, Jest, Mocha, etc., and attempt to
build a fluent, chainable API in the style of an assertion library. As an
example, I'd like to be able to do something like this:

```js
Check(value).isType('string').matches(/regex/).guard();
```

For the most part, I think reading this is pretty self explanatory. `Check` is
the overall API name, and we check to make sure the value is a string and
matches some regex. Finally, the `guard` method - a name I'm not completely sold
on yet - can be used to throw an exception if the checks aren't passed or
omitted to perform the validation without throwing.

The big difference between what I hope to achieve and existing assertion
libraries, is I want to use it for runtime checking, logging, and error
handling. Assertion libraries are primarily used for non-production testing and
development and the related `assert` calls are frequently stripped out of
production code. Although the API and underlying checks are similar, and I may
create an assert wrapper for my library in the future, my current use case does
not align with existing assertion libraries.

## Notable features and design choices

The inner workings of this utility is pretty simple, but very verbose, simply
due to the number of checks, branches, and chaining methods implemented. For
brevity's sake, I'm just going to call out some of the high-level features
implemented and design choices I made, then focus on the actual usage of the API
itself.

### Real classes (sort of, it's still JS)

ServiceNow script includes rely on `prototype.js` for the native class
implementation. Although I typically prefer simple namespace methods to classes
in ServiceNow, because I wanted a fluent, chainable API with persistent state
across method calls, a class was an obvious fit for this use case - but I
decided to take a different approach.

Since ServiceNow finally supports modern JavaScript, I leveraged a standard
JavaScript class. As long as the class name matches the script include name,
it's accessible like any other script include. I created the
[Checker](/docs/servicenow/check) class to store the type validation, assertion,
and error handling logic.

This brings a couple benefits I wanted to leverage - it doesn't depend on
prototype, making the code more portable, and I can leverage standard class
features like getters and setters. A getter allows a `not` property to be
exposed to invert the result of a check, rather than requiring our users to call
a `not()` method, so we can write something like:

```js
// the 'is' and 'not' getter properties compute their value when accessed
Check(value).is.not.type('string');
// rather than calling standard class methods
Check(value).not().isType('string');
```

You can also use the getters to define simple a pass through, like 'is' (shown
above), 'to', 'be', etc. that don't do anything except return `this`. I'll use
these to make the API more human readable and grammatically correct, but behind
the scenes,

### The Façade

Even with the advent of ES6 classes, I'm still not generally a fan. I find they
are often misused or used when a simple collection of standalone functions would
suffice. It's a minor thing, but especially when a class is instantiated over
and over (as will be the case when validating many input parameters), the need
to call `new` repeatedly drives me crazy. Because of this, I also created a
server-side namespace named [Type](/docs/servicenow/type). The `Type` namespace
contains some standalone methods, like retrieving additional details on an
object type, but importantly exposes a factory function called `check` which
instantiates the TypeChecker behind the scenes.

<Alert type="note">
	I originally exposed a factory in the [Type](/docs/servicenow/type) utility
	as described above, but as I shifted from simple type checking to more
	general validation, it no longer made sense. Now, the `Check` factory
	function and the `Checker` class both live in the same
	[Check](/docs/servicenow/check) script include, but I think the original
	pattern was interesting enough to leave as a reference.
</Alert>

Using the facade/factory makes the developer experience much nicer in my
opinion. The API can be accessed by calling `Check`, which instantiates a new
`Checker` object without requiring the user to write `new` over and over. Here's
what API looks like with and without using the façade.

```js
// using the TypeChecker directly
new Checker(name, value).is.not.type('null').guard();

// using the Type namespace
Check(name, value).is.not.type('string').guard();

// the Factory could also take an object with a single key to simplify check(name, value)
Check({ value }).is.not.type('string').guard();
```

## Chaining multiple checks

It's rare that I need to validate just one input. I want an API that makes it
simple to chain multiple checks together. Exposing a `check` method on the
`Checker` class (remember, the factory is `Check`) means we can use the same
verb to define a new check. The difference in capitalization indicates which
method instantiates the object.

Now, we can chain multiple tests against the same value, multiple checks against
different values, and return an aggregated result with consistent validation
errors for logging or throwing an exception.

```js
// prettier-ignore
let result = Check({ value }).is.type('string').matches(/regex/)
	.check({ anotherValue }).is.not.type('null')
	.check({ numberValue }).is.type('number').greater(0)
    // call .result() to return the aggregate details or .guard() to throw
    .result();
```

## Final Structure

In the end, we have a [Type](/docs/servicenow/type) namespace that includes
simple type check aliases, methods to get the internal `@@toStringTag` (formerly
the `[[class]]` property), and other complex type checks, like checking if an
object is a plain vanilla object or an instance of another object type.

Next, we have the [Check](/docs/servicenow/check) namespace that defines the
`Checker` class and does the heavy lifting of input validation, message
templating, and error handling, but it also makes use of the `Type` methods for
some of the basic type checks.

Neither utility is anywhere near complete. There are many checks I want to add
to the `Checker` class and I want to make the logic for identifying the
JavaObject type much more robust in the `Type` utility. For now, they are
functional enough to start using and I'll add additional functionality as I need
it.
