---
import {
	extractBreadcrumbs,
	findNamespaceReadmePath,
	getTypedocPageMap,
	getTypedocReadmeMap,
	trimSlashes,
	rewriteTypedocSectionHref,
	rewriteTypedocRelativeHref,
	rewriteRelativeLinks,
	stripFirstH1,
	stripFirstH1Paragraph,
	pathnameToBaseUrl,
	typedocDiskPathToPublicId,
	loadCompiledHtmlFromGlob,
} from '@utils/typedoc.js';

const { apiPath, variant = 'root' } = Astro.props;
const rel = trimSlashes(apiPath);
const pageMap = getTypedocPageMap();
const apiRootPath = `/docs/${rel}`;
let rawHtml = null;
let baseUrl = null;
let rewriteOpts = {};

if (variant === 'namespace') {
	const namespaceReadmePath = findNamespaceReadmePath(pageMap, rel);

	if (namespaceReadmePath) {
		rawHtml = await loadCompiledHtmlFromGlob(pageMap, namespaceReadmePath, 'TypeDoc namespace README');
		const namespacePublicId = typedocDiskPathToPublicId(namespaceReadmePath, pageMap);
		baseUrl = namespacePublicId === rel
			? `/docs/${rel}`
			: pathnameToBaseUrl(`/docs/${namespacePublicId}`);
		rewriteOpts = {
			stripMdExt: true,
			rewriteRelativeHref: (href) => {
				return (
					rewriteTypedocRelativeHref(href, rel, pageMap) ??
					rewriteTypedocSectionHref(href, rel)
				);
			},
		};
	}
} else {
	const readmeMap = getTypedocReadmeMap();
	const typedocPath = `/docs/${rel}/typedoc/README.md`;
	rawHtml = await loadCompiledHtmlFromGlob(readmeMap, typedocPath, 'TypeDoc README');
	baseUrl = apiRootPath;
	rewriteOpts = {
		stripMdExt: true,
		rewriteRelativeHref: (href) => {
			return (
				rewriteTypedocRelativeHref(href, rel, pageMap) ??
				rewriteTypedocSectionHref(href, rel)
			);
		},
	};
}

let fixedHtml = null;
if (rawHtml && baseUrl) {
	fixedHtml = rewriteRelativeLinks(rawHtml, baseUrl, rewriteOpts);
	if (variant === 'namespace') {
		const extracted = extractBreadcrumbs(fixedHtml);
		fixedHtml = extracted.html ?? fixedHtml;
	}
	if (variant === 'namespace') {
		fixedHtml = stripFirstH1Paragraph(fixedHtml);
	}
	fixedHtml = stripFirstH1(fixedHtml);
}
---

{fixedHtml && <div set:html={fixedHtml} />}
